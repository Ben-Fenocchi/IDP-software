//#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include "Arduino.h"
#include "Wire.h"
#include "DFRobot_VL53L0X.h"
#include <Servo.h>

//----------------------------------Code to let us use arrays----------------------------------------
struct Node {
  int data;
  Node *next;
};

//initialises the lists
Node *pathListBig = nullptr;  //holds the list of turns in order to make
Node *goHomeList = nullptr;   //holds the list of turns in order to make


//fuctions to add to lists(appends to the front of lists)
void appendToBigList(int value) {
  Node *newNode = new Node;
  newNode->data = value;
  newNode->next = pathListBig;
  pathListBig = newNode;
}
void appendToGoHomeList(int value) {
  Node *newNode = new Node;
  newNode->data = value;
  newNode->next = goHomeList;
  goHomeList = newNode;
}


//function to remove from list
void removeFromBigList() {
  if (pathListBig != nullptr) {
    Node *temp = pathListBig;
    pathListBig = pathListBig->next;
    delete temp;
  }
}
void removeFromGoHomeList() {
  if (pathListBig != nullptr) {
    Node *temp = goHomeList;
    goHomeList = goHomeList->next;
    delete temp;
  }
}


//---------------------------------------Setup for variables-----------------------------------------


//ultrasound setup
#define MAX_RANG (520)
#define ADC_SOLUTION (1023.0)

Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *leftMotor = AFMS.getMotor(1);
Adafruit_DCMotor *rightMotor = AFMS.getMotor(2);


DFRobot_VL53L0X tofSensor;  //creating tof object
Servo myServo;              // create servo object to control a servo
int servoPos = 0;           // variable to store the servo position

//pin setups
int sideSensor = A0;  //ultrasound sensor
int frLS = 2;         // front right line sensor
int flLS = 5;         // front left line sensor
int leftLS = 3;       // left side line sensor
int rightLS = 4;      // right side line sensor
int redLED = 12;
int greenLED = 13;
int resetButton = 7;

//variable set ups
int reading;                  //defined to use later as the tof reading variable
float dist_t, sensity_t;      //for the ultrasound sensor
int oldSpeedLeft = 0;         // Declare oldSpeed as a global variable
int oldSpeedRight = 0;        // Declare oldSpeed as a global variable
int valLeft = 0;              // Declare valLeft as a global variable
int valRight = 0;             // Declare valRight as a global variable
float distanceAfterTurn = 0;  // Declare distanceAfterTurn as a global variable

//n.b if change these here also need to change in reset function
int defaultSpeed = 200;
int extremeAdjustmentSpeed = 250;
int adjustmentSpeed = 175;
int home = 1;  //so we know when we are home
//constants
const int error = 20;  // for the error on the ultrasound reading



//--------------------------------------------------functions-----------------------------------------

void speedLeft(int speed) {
  speed = speed * -1;
  if (speed == oldSpeedLeft) {
    return;
  } else {
    if (speed < 0) {
      leftMotor->run(BACKWARD);
      leftMotor->setSpeed(speed * -1);
    } else {
      leftMotor->run(FORWARD);
      leftMotor->setSpeed(speed);
    }
    oldSpeedLeft = speed;
  }
}
void speedRight(int speed) {
  speed = speed * -1;
  if (speed == oldSpeedRight) {
    return;
  } else {
    if (speed < 0) {
      rightMotor->run(BACKWARD);
      rightMotor->setSpeed(speed * -1);
    } else {
      rightMotor->run(FORWARD);
      rightMotor->setSpeed(speed);
    }
    oldSpeedRight = speed;
  }
}
void leftTurn() {
  sensity_t = analogRead(sideSensor);
  dist_t = sensity_t * MAX_RANG / ADC_SOLUTION;
  speedRight( -150);
  speedLeft( 150);
  delay(2700);  //give time for left sensor to get off white line
  distanceAfterTurn = dist_t;
  Serial.println(distanceAfterTurn);
  Serial.println("turn finished");
  appendToGoHomeList(0);  //so we can reverse the turns to get home.
                          //N.B have appended 0 even though this is a left turn as it is reversing home
}
void rightTurn() {
  sensity_t = analogRead(sideSensor);
  dist_t = sensity_t * MAX_RANG / ADC_SOLUTION;
  speedRight( 150);
  speedLeft( -150);
  delay(2700);  //give time for left sensor to get off white line
  distanceAfterTurn = dist_t;
  Serial.println(distanceAfterTurn);
  Serial.println("turn finished");
  appendToGoHomeList(1);  //so we can reverse the turns to get home.
                          //N.B have appended 1 even though this is a right turn as it is reversing home
}
void followLine() {
  int valLeft = digitalRead(flLS);
  int valRight = digitalRead(frLS);
  //if left is on and right is off, slow down the left one
  if (valLeft > valRight) {
    speedRight( defaultSpeed );
    speedLeft( adjustmentSpeed);
  }
  //if right is on and left is off, slow down the right one
  else if (valRight > valLeft) {
    speedLeft( defaultSpeed);
    speedRight( adjustmentSpeed);
  }
  //if both are on then set speed to forward
  else if (valRight == valLeft) {
    speedLeft( defaultSpeed);
    speedRight( defaultSpeed);
  }
}
void moveToJunction(Node *listName) {
  followLine();
  if (digitalRead(leftLS)) {
    Serial.println("Junction");
    speedLeft( 1);
    speedRight( 1);
    delay(1000);
    //Serial.println(pathListBig->data);
    if (listName->data == 1) {
      Serial.println("turning left");
      leftTurn();
      removeFromBigList();
      
    } else if (listName->data == 0) {
      Serial.println("Turning right");
      rightTurn();
      removeFromBigList();

    } else {
      Serial.println("going Straight");
      speedLeft( defaultSpeed);
      speedRight( defaultSpeed);
      removeFromBigList();
      
    }
    speedLeft( defaultSpeed);
    speedRight( defaultSpeed);
    delay(2000);//to make sure it can get off the junction and not redect it
  }
}

void checkForBlockDownwards() {
  //values for the tof sensor when touching cubes
  //46 dense
  //58 less dense
  reading = tofSensor.getDistance();
  //Serial.println(reading);
  if (reading < 50) {
    Serial.println("Block");
    blockBurglar();
  }
}
//to trap the block in the cage
void blockBurglar() {
  // goes from 0 degrees to 180 degrees in steps of 1 degree
  for (servoPos = 0; servoPos <= 50; servoPos += 1) {
    myServo.write(servoPos);  // tell servo to go to position in variable 'pos'
    delay(15);                // waits 15 ms for the servo to reach the position
  }
  //if higher density block
  if (reading<55){
    digitalWrite(redLED, HIGH);
  }
  else{
    digitalWrite(greenLED, LOW);
  }
  //ETgoHome();
}

void ultrasonicCheck() {
  sensity_t = analogRead(sideSensor);
  dist_t = sensity_t * MAX_RANG / ADC_SOLUTION;
  if (dist_t < distanceAfterTurn - error) {
    Serial.println("Block found");
    Serial.println(dist_t);
    retrieveSideBlock();
  }
}
void retrieveSideBlock() {
  Serial.println("retrieving side block");
  //reverses a bit
  speedLeft( -50);
  speedRight( -50);
  delay(1000);

  //makes turn
  leftTurn();
  speedLeft( defaultSpeed);
  speedRight( defaultSpeed);
  while (reading > 100) {  //while we havent ran into the block yet, determined w the tof sensor
    
      if (digitalRead(resetButton)) {
        reset();
      }
  }
  speedLeft( 0);
  speedRight( 0);
  delay(3000);
  Serial.println("blocky uh");
  //returning to original line
  while (digitalRead(leftLS) < 1) {
    if (digitalRead(resetButton)) {
      reset();
    }
    speedLeft( -defaultSpeed);
    speedRight( -defaultSpeed);
    Serial.println("Reversing back to line");
  }
  speedLeft( 0);
  speedRight( 0);
  delay(3000);
  Serial.println("Found old line");
  rightTurn();
  delay(3000);
  //ETgoHome();
}
/*
void ETgoHome(){
    //code to reverse pathways home
    defaultSpeed = defaultSpeed *-1;
    lineSpeedAdjustment = lineSpeedAdjustment * -1;
    while (home = 0){
        moveToJunction(goHomeList);
        if ((goHomeList ->data) = nullptr){
            home = 1;
            Serial.println("We are home");
        }
    }
}
*/

void reset() {
  Serial.println("reset");
  distanceAfterTurn = 10000000;
  speedLeft( 0);
  speedRight( 0);
  digitalWrite(redLED, LOW);
  digitalWrite(redLED, LOW);

  
  home = 0;
  defaultSpeed = 180;
  lineSpeedAdjustment = 75;
  //resettting the hugger
  myServo.write(0);

  //emptying lists
  while (pathListBig != nullptr) {
    removeFromBigList();
  }
  while (goHomeList != nullptr) {
    removeFromGoHomeList();
  }

  //adding the list values back
  appendToBigList(2);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(0);
  appendToBigList(2);
  
  delay(2000);
  speedLeft( defaultSpeed);
  speedRight( defaultSpeed);
}


//-------------------------------------------------main program-------------------------------------------
void setup() {
  Serial.begin(9600);
  Wire.begin();
  tofSensor.begin(0x50);
  tofSensor.setMode(tofSensor.eContinuous,tofSensor.eHigh);
  tofSensor.start();
  pinMode(sideSensor, INPUT);  // the ultrasound sensor

  pinMode(frLS, INPUT);
  pinMode(flLS, INPUT);
  pinMode(leftLS, INPUT);
  pinMode(rightLS, INPUT);

  pinMode(redLED, OUTPUT);
  pinMode(greenLED, OUTPUT);

  pinMode(resetButton, INPUT);

  myServo.attach(6);  // attaches the servo on pin 6 to the servo object

  //list for pathways
  //path to follow,  0 for a right, 1 for a left turn,2 for straight//N.B append function adds to the start of the list
  appendToBigList(2);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(1);
  appendToBigList(2);
  appendToBigList(0);
  appendToBigList(2);


  if (!AFMS.begin()) {
    Serial.println("Could not find Motor Shield. Check wiring.");
    while (1)
      ;
  }
  Serial.println("Motor Shield found.");
  myServo.write(0);
}


void loop() {

  if (digitalRead(resetButton)) {
    reset();
  }
  checkForBlockDownwards();
  speedRight( defaultSpeed);
  speedLeft( defaultSpeed);
  moveToJunction(pathListBig);
  ultrasonicCheck();
}
