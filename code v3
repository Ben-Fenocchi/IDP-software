#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#include "Arduino.h"
#include "Wire.h"
#include "DFRobot_VL53L0X.h"

//lets us use arrays
struct Node {
  int data;
  Node * next;
};

//initialises the list turningList and turnsList
Node* turningList = nullptr; //holds the details for a turn
Node* pathListBig = nullptr; //holds the list of turns in order to make
Node* ultraListBig = nullptr;//holds list of ultrasonic distances at each point, if no block in way


//fuction to add to list
void appendToList(int value,listName){
  Node * newNode = new Node;
  newNode->data = value;
  newNode->next = listName;
  listName = newNode; 
}

//function to remove from list
void removeFromList(listName) {
  if (listName != nullptr) {
    Node* temp = listName;
    listName = listName->next;
    delete temp;
  }
}


//tof setup
DFRobot_VL53L0X tofSensor;

//ultrasound setup
#define MAX_RANG (520)
#define ADC_SOLUTION (1023.0)


Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *leftMotor = AFMS.getMotor(1);
Adafruit_DCMotor *rightMotor = AFMS.getMotor(2);

Servo myservo; // create servo object to control a servo
int servoPos = 0; // variable to store the servo position
myservo.attach(6); // attaches the servo on pin 6 to the servo object


int sideSensor = A0;//ultrasound sensor
int frLS = 5; // front right line sensor
int flLS = 2; // front left line sensor
int leftLS = 3;// left side line sensor
int rightLS = 4;// right side line sensor
int redLED =12;
int greenLED = 13;

int reading //defined to use later as the tof reading variable
float dist_t, sensity_t;//for the ultrasound sensor

int defaultSpeed = 80;
int oldSpeedLeft = 0;  // Declare oldSpeed as a global variable
int oldSpeedRight = 0;  // Declare oldSpeed as a global variable
int valLeft = 0;   // Declare valLeft as a global variable
int valRight = 0;  // Declare valRight as a global variable

void setup() {
    Serial.begin(9600);
    
    pinMode(sideSensor, INPUT); // the ultrasound sensor
    
    pinMode(frLS, INPUT);
    pinMode(flLS, INPUT);
    pinMode(leftLS, INPUT);
    pinMode(rightLS, INPUT);

    pinMode(redLED, OUTPUT);
    pinMode(greenLED,OUTPUT);

    //list for the turning
    appendToList(1,turningList);
    appendToList(0,turningList);
    appendToList(1,turningList);
    //appendToList(0,turningList);

    //list for pathways
    //path to follow,  0 for a right, 1 for a left turn,2 for straight
    appendToList(2,pathListBig);
    appendToList(0,pathListBig);
    appendToList(2,pathListBig);
    appendToList(1,pathListBig);
    appendToList(2,pathListBig);
    appendToList(1,pathListBig);
    appendToList(1,pathListBig);
    appendToList(2,pathListBig);
    appendToList(1,pathListBig);
    appendToList(2,pathListBig);
    appendToList(2,pathListBig);

    //list for ultrasonic values for after each junction turn
    //values: 52, 165, 165, 211, 211, 210, 211, 211, 165, 165, 165
    appendToList(52,ultraListBig);
    appendToList(165,ultraListBig);
    appendToList(165,ultraListBig);
    appendToList(211,ultraListBig);
    appendToList(211,ultraListBig);
    appendToList(210,ultraListBig);
    appendToList(211,ultraListBig);
    appendToList(211,ultraListBig);
    appendToList(165,ultraListBig);
    appendToList(165,ultraListBig);
    appendToList(165,ultraListBig);


    if (!AFMS.begin()) {
        Serial.println("Could not find Motor Shield. Check wiring.");
        while (1);
    }
    Serial.println("Motor Shield found.");
}



void speedLeft(Adafruit_DCMotor *motorName, int speed) {
    speed = speed *-1;
    if (speed == oldSpeedLeft) {
        return;
        
    } else {
        if (speed < 0) {
            motorName->run(BACKWARD);
            motorName->setSpeed(speed * -1);
            
        } else {
            motorName->run(FORWARD);
            motorName->setSpeed(speed);
            
        }
        oldSpeedLeft = speed;

  
    }
}
void speedRight(Adafruit_DCMotor *motorName, int speed) {
  speed = speed *-1;
    if (speed == oldSpeedRight) {
        return;
        
    } else {
        if (speed < 0) {
            motorName->run(BACKWARD);
            motorName->setSpeed(speed * -1);
        } else {
            motorName->run(FORWARD);
            motorName->setSpeed(speed);
        }
        oldSpeedRight = speed;
  
    }
}



void followLine() {
    int valLeft = digitalRead(flLS);
    int valRight = digitalRead(frLS);
    if (valLeft > valRight) {
        speedRight(rightMotor, defaultSpeed);
        speedLeft(leftMotor, defaultSpeed+40);
    }
    if (valRight> valLeft){
        speedLeft(leftMotor, defaultSpeed);
        speedRight(rightMotor, defaultSpeed+40);
    }
}

void moveToJunction() {
    followLine();
    if (digitalRead(leftLS)) {
        Serial.println("Junction");
        speedLeft(leftMotor, 1);
        speedRight(rightMotor,1);
        if (pathListBig->data == 1){
            leftTurn();
            removeFromList(pathListBig);
            delay(1000);
        }
        elif (pathListBig->data == 0){
            rightTurn();
            removeFromList(pathListBig);
            delay(1000);//delay to make sure the car can get off the junction so it doesnt stay at the same one and keep turning
        }
        else{
            speedLeft(leftMotor, defaultSpeed);
            speedRight(rightMotor,defaultSpeed);
            removeFromList(pathListBig);
            delay(1000);
        }
        
    }
}

void leftTurn() {

    speedLeft(leftMotor, -50);
    speedRight(rightMotor, 75);
    delay(3000);

    while (turningList != nullptr){//while list not empty
     
      if (digitalRead(leftLS)==turningList->data){
        removeFromList(turningList);
        
      }
    // resetting the turning list

    appendToList(1,turningList);
    appendToList(0,turningList);
    appendToList(1,turningList);
    //appendToList(0,turningList);
    }

    Serial.println("turn finished");
    speedLeft(leftMotor,defaultSpeed);
    speedRight(rightMotor,defaultSpeed);

}

void rightTurn() {
    speedRight(rightMotor, -50);
    speedLeft(leftMotor, 50);

    delay(3000);

    while (turningList != nullptr){//while list not empty
     
      if (digitalRead(leftLS)==turningList->data){
        removeFromList(turningList);
        
      }
    // resetting the turning list

    appendToList(1,turningList);
    appendToList(0,turningList);
    appendToList(1,turningList);
    //appendToList(0,turningList);
    }

    Serial.println("turn finished");
    speedLeft(leftMotor,defaultSpeed);
    speedRight(rightMotor,defaultSpeed);
}


void checkForBlockDownwards(){
    //values for the tof sensor when touching cubes
    //46 dense
    //58 less dense
    reading = tofSensor.getDistance();
    if (reading < 30){
        Serial.println("Block");
        blockBurglar();
    }
    
}
//to trap the block in the cage
void blockBurglar(){
    // goes from 0 degrees to 180 degrees in steps of 1 degree
    for (pos = 0; pos <= 180; pos += 1) { 
        myservo.write(pos); // tell servo to go to position in variable 'pos'
        delay(15); // waits 15 ms for the servo to reach the position
    }

}




void loop() {
  
  speedRight(rightMotor, defaultSpeed);
  speedLeft(leftMotor, defaultSpeed);
  moveToJunction();
  }
  








